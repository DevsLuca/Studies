# CLRS - Introduction to Algorithms
*THOMAS H. CORMEN, CHARLES E. LEISERSON, RONALD L. RIVEST, CLIFFORD STEIN*

Introduction to Algorithms by Cormen, Leiserson, Rivest, and Stein (CLRS) is a canonical text on algorithms that covers the design, analysis, and implementation of efficient algorithms. The book spans fundamental data structures, graph algorithms, optimization techniques, and advanced topics, with a strong focus on mathematical rigor and problem-solving.
---

## I. Foundations

### Introduction

### 1. The Role of Algorithms in Computing
- [x] 1.1 Algorithms  
- [x] 1.2 Algorithms as a Technology  

### 2. Getting Started
- [x] 2.1 Insertion Sort  
- [x] 2.2 Analyzing Algorithms  
- [x] 2.3 Designing Algorithms  

### 3. Growth of Functions
- [x] 3.1 Asymptotic Notation  
- [x] 3.2 Standard Notations and Common Functions  

### 4. Divide-and-Conquer
- [x] 4.1 The Maximum-Subarray Problem  
- [x] 4.2 Strassen’s Algorithm for Matrix Multiplication  
- [x] 4.3 The Substitution Method for Solving Recurrences  
- [x] 4.4 The Recursion-Tree Method for Solving Recurrences  
- [x] 4.5 The Master Method for Solving Recurrences  
- [x] 4.6 Proof of the Master Theorem  

### 5. Probabilistic Analysis and Randomized Algorithms
- [x] 5.1 The Hiring Problem  
- [x] 5.2 Indicator Random Variables  
- [x] 5.3 Randomized Algorithms  
- [x] 5.4 Probabilistic Analysis and Further Uses of Indicator Random Variables  

---

## II. Sorting and Order Statistics

### Introduction

### 6. Heapsort
- [x] 6.1 Heaps  
- [x] 6.2 Maintaining the Heap Property  
- [x] 6.3 Building a Heap  
- [x] 6.4 The Heapsort Algorithm  
- [x] 6.5 Priority Queues  

### 7. Quicksort
- [x] 7.1 Description of Quicksort  
- [x] 7.2 Performance of Quicksort  
- [x] 7.3 A Randomized Version of Quicksort  
- [x] 7.4 Analysis of Quicksort  

### 8. Sorting in Linear Time
- [x] 8.1 Lower Bounds for Sorting  
- [x] 8.2 Counting Sort  
- [x] 8.3 Radix Sort  
- [x] 8.4 Bucket Sort  

### 9. Medians and Order Statistics
- [x] 9.1 Minimum and Maximum  
- [x] 9.2 Selection in Expected Linear Time  
- [x] 9.3 Selection in Worst-Case Linear Time  

---

## III. Data Structures

### Introduction

### 10. Elementary Data Structures
- [x] 10.1 Stacks and Queues  
- [x] 10.2 Linked Lists  
- [x] 10.3 Implementing Pointers and Objects  
- [x] 10.4 Representing Rooted Trees  

### 11. Hash Tables
- [x] 11.1 Direct-Address Tables  
- [x] 11.2 Hash Tables  
- [x] 11.3 Hash Functions  
- [x] 11.4 Open Addressing  
- [x] 11.5 Perfect Hashing  

### 12. Binary Search Trees
- [x] 12.1 What Is a Binary Search Tree?  
- [x] 12.2 Querying a Binary Search Tree  
- [x] 12.3 Insertion and Deletion  
- [x] 12.4 Randomly Built Binary Search Trees  

### 13. Red-Black Trees
- [ ] 13.1 Properties of Red-Black Trees  
- [ ] 13.2 Rotations  
- [ ] 13.3 Insertion  
- [ ] 13.4 Deletion  

### 14. Augmenting Data Structures
- [ ] 14.1 Dynamic Order Statistics  
- [ ] 14.2 How to Augment a Data Structure  
- [ ] 14.3 Interval Trees  

---

## IV. Advanced Design and Analysis Techniques

### Introduction

### 15. Dynamic Programming
- [ ] 15.1 Rod Cutting  
- [ ] 15.2 Matrix-Chain Multiplication  
- [ ] 15.3 Elements of Dynamic Programming  
- [ ] 15.4 Longest Common Subsequence  
- [ ] 15.5 Optimal Binary Search Trees  

### 16. Greedy Algorithms
- [ ] 16.1 An Activity-Selection Problem  
- [ ] 16.2 Elements of the Greedy Strategy  
- [ ] 16.3 Huffman Codes  
- [ ] 16.4 Matroids and Greedy Methods  
- [ ] 16.5 A Task-Scheduling Problem as a Matroid  

### 17. Amortized Analysis
- [ ] 17.1 Aggregate Analysis  
- [ ] 17.2 The Accounting Method  
- [ ] 17.3 The Potential Method  
- [ ] 17.4 Dynamic Tables  

---

## V. Advanced Data Structures

### Introduction

### 18. B-Trees
- [ ] 18.1 Definition of B-Trees  
- [ ] 18.2 Basic Operations on B-Trees  
- [ ] 18.3 Deleting a Key from a B-Tree  

### 19. Fibonacci Heaps
- [ ] 19.1 Structure of Fibonacci Heaps  
- [ ] 19.2 Mergeable-Heap Operations  
- [ ] 19.3 Decreasing a Key and Deleting a Node  
- [ ] 19.4 Bounding the Maximum Degree  

### 20. van Emde Boas Trees
- [ ] 20.1 Preliminary Approaches  
- [ ] 20.2 A Recursive Structure  
- [ ] 20.3 The van Emde Boas Tree  

### 21. Data Structures for Disjoint Sets
- [ ] 21.1 Disjoint-Set Operations  
- [ ] 21.2 Linked-List Representation of Disjoint Sets  
- [ ] 21.3 Disjoint-Set Forests  
- [ ] 21.4 Analysis of Union by Rank with Path Compression  

---

## VI. Graph Algorithms

### Introduction

### 22. Elementary Graph Algorithms
- [ ] 22.1 Representations of Graphs  
- [ ] 22.2 Breadth-First Search  
- [ ] 22.3 Depth-First Search  
- [ ] 22.4 Topological Sort  
- [ ] 22.5 Strongly Connected Components  

### 23. Minimum Spanning Trees
- [ ] 23.1 Growing a Minimum Spanning Tree  
- [ ] 23.2 The Algorithms of Kruskal and Prim  

### 24. Single-Source Shortest Paths
- [ ] 24.1 The Bellman-Ford Algorithm  
- [ ] 24.2 Shortest Paths in Directed Acyclic Graphs  
- [ ] 24.3 Dijkstra’s Algorithm  
- [ ] 24.4 Difference Constraints and Shortest Paths  
- [ ] 24.5 Proofs of Shortest-Paths Properties  

### 25. All-Pairs Shortest Paths
- [ ] 25.1 Shortest Paths and Matrix Multiplication  
- [ ] 25.2 The Floyd-Warshall Algorithm  
- [ ] 25.3 Johnson’s Algorithm for Sparse Graphs  

### 26. Maximum Flow
- [ ] 26.1 Flow Networks  
- [ ] 26.2 The Ford-Fulkerson Method  
- [ ] 26.3 Maximum Bipartite Matching  
- [ ] 26.4 Push-Relabel Algorithms  
- [ ] 26.5 The Relabel-to-Front Algorithm  

---

## VII. Selected Topics

### Introduction

### 27. Multithreaded Algorithms
- [ ] 27.1 The Basics of Dynamic Multithreading  
- [ ] 27.2 Multithreaded Matrix Multiplication  
- [ ] 27.3 Multithreaded Mergesort  

### 28. Matrix Operations
- [ ] 28.1 Solving Systems of Linear Equations  
- [ ] 28.2 Inverting Matrices  
- [ ] 28.3 Symmetric Positive-Definite Matrices and Least-Squares Approximation  

### 29. Linear Programming
- [ ] 29.1 Standard and Slack Forms  
- [ ] 29.2 Formulating Problems as Linear Programs  
- [ ] 29.3 The Simplex Algorithm  
- [ ] 29.4 Duality  
- [ ] 29.5 The Initial Basic Feasible Solution  

### 30. Polynomials and the FFT
- [ ] 30.1 Representing Polynomials  
- [ ] 30.2 The DFT and FFT  
- [ ] 30.3 Efficient FFT Implementations  

### 31. Number-Theoretic Algorithms
- [ ] 31.1 Elementary Number-Theoretic Notions  
- [ ] 31.2 Greatest Common Divisor  
- [ ] 31.3 Modular Arithmetic  
- [ ] 31.4 Solving Modular Linear Equations  
- [ ] 31.5 The Chinese Remainder Theorem  
- [ ] 31.6 Powers of an Element  
- [ ] 31.7 The RSA Public-Key Cryptosystem  
- [ ] 31.8 Primality Testing  
- [ ] 31.9 Integer Factorization  

### 32. String Matching
- [ ] 32.1 The Naive String-Matching Algorithm  
- [ ] 32.2 The Rabin-Karp Algorithm  
- [ ] 32.3 String Matching with Finite Automata  
- [ ] 32.4 The Knuth-Morris-Pratt Algorithm  

### 33. Computational Geometry
- [ ] 33.1 Line-Segment Properties  
- [ ] 33.2 Determining Whether Any Pair of Segments Intersects  
- [ ] 33.3 Finding the Convex Hull  
- [ ] 33.4 Finding the Closest Pair of Points  

### 34. NP-Completeness
- [ ] 34.1 Polynomial Time  
- [ ] 34.2 Polynomial-Time Verification  
- [ ] 34.3 NP-Completeness and Reducibility  
- [ ] 34.4 NP-Completeness Proofs  
- [ ] 34.5 NP-Complete Problems  

### 35. Approximation Algorithms
- [ ] 35.1 The Vertex-Cover Problem  
- [ ] 35.2 The Traveling-Salesman Problem  
- [ ] 35.3 The Set-Covering Problem  
- [ ] 35.4 Randomization and Linear Programming  
- [ ] 35.5 The Subset-Sum Problem  

---

## VIII. Appendix: Mathematical Background

### Introduction

### A. Summations
- [ ] A.1 Summation Formulas and Properties  
- [ ] A.2 Bounding Summations  

### B. Sets, Etc.
- [ ] B.1 Sets  
- [ ] B.2 Relations  
- [ ] B.3 Functions  
- [ ] B.4 Graphs  
- [ ] B.5 Trees  

### C. Counting and Probability
- [ ] C.1 Counting  
- [ ] C.2 Probability  
- [ ] C.3 Discrete Random Variables  
- [ ] C.4 The Geometric and Binomial Distributions  
- [ ] C.5 The Tails of the Binomial Distribution  

### D. Matrices
- [ ] D.1 Matrices and Matrix Operations  
- [ ] D.2 Basic Matrix Properties  

---

## Bibliography

## Index
